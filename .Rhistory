git init
rmarkdown::run("Swapdash_v0.2.Rmd")
getwd()
setwd("/Volumes/Loopdisk/Swapboard")
getwd()
rmarkdown::run("Swapdash_v0.2.Rmd")
rmarkdown::run("Swapdash_v0.2.Rmd")
# Gets the port # from Heroku
port <- Sys.getenv('PORT')
#
# run.R
# Swapboard
#
# Created by Tosin on 26/11/2019
# MIT License and shit
#
#library(rmarkdown)
library(shiny)
# When we run nginx we need to change R to point to the /app folder manually
#setwd('/app')
# Create a file at the path /tmp/app-initalized
# This tells nginx that the app is running, and it can now forward traffic to the custom 'port' below
# If this file is created, nginx will simply wait forever until the app says its running
##file.create("/tmp/app-initialized")
##port <- '/tmp/nginx.socket'
##attr(port, 'mask') <- strtoi("117", 8)
# Gets the port # from Heroku
port <- Sys.getenv('PORT')
shiny::runApp(
appDir = getwd(),
host = '0.0.0.0',
port = as.numeric(port)
)
# Runs the app in the working directory. By default this will search for an `app.R` file or
# a ui.R + server.R file combination
# In this case the port is now the address to the nginx proxy
# The host of 0.0.0.0 indicates the app runs at the web server's ip address
rmarkdown::run(
'Swapdash_v0.2.Rmd',
shiny_args = list(
port = port)
)
#
# run.R
# Swapboard
#
# Created by Tosin on 26/11/2019
# MIT License and shit
#
#library(rmarkdown)
library(shiny)
# When we run nginx we need to change R to point to the /app folder manually
#setwd('/app')
# Create a file at the path /tmp/app-initalized
# This tells nginx that the app is running, and it can now forward traffic to the custom 'port' below
# If this file is created, nginx will simply wait forever until the app says its running
##file.create("/tmp/app-initialized")
##port <- '/tmp/nginx.socket'
##attr(port, 'mask') <- strtoi("117", 8)
# Gets the port # from Heroku
shiny::runApp(
appDir = getwd()
)
# Runs the app in the working directory. By default this will search for an `app.R` file or
# a ui.R + server.R file combination
# In this case the port is now the address to the nginx proxy
# The host of 0.0.0.0 indicates the app runs at the web server's ip address
rmarkdown::run(
'Swapdash_v0.2.Rmd'
)
#
# run.R
# Swapboard
#
# Created by Tosin on 26/11/2019
# MIT License and shit
#
#library(rmarkdown)
library(shiny)
# When we run nginx we need to change R to point to the /app folder manually
#setwd('/app')
# Create a file at the path /tmp/app-initalized
# This tells nginx that the app is running, and it can now forward traffic to the custom 'port' below
# If this file is created, nginx will simply wait forever until the app says its running
##file.create("/tmp/app-initialized")
##port <- '/tmp/nginx.socket'
##attr(port, 'mask') <- strtoi("117", 8)
# Gets the port # from Heroku
#port <- Sys.getenv('PORT')
shiny::runApp(
appDir = getwd()
)
# Runs the app in the working directory. By default this will search for an `app.R` file or
# a ui.R + server.R file combination
# In this case the port is now the address to the nginx proxy
# The host of 0.0.0.0 indicates the app runs at the web server's ip address
#
# run.R
# Swapboard
#
# Created by Tosin on 26/11/2019
# MIT License and shit
#
#library(rmarkdown)
library(shiny)
# When we run nginx we need to change R to point to the /app folder manually
#setwd('/app')
# Create a file at the path /tmp/app-initalized
# This tells nginx that the app is running, and it can now forward traffic to the custom 'port' below
# If this file is created, nginx will simply wait forever until the app says its running
##file.create("/tmp/app-initialized")
##port <- '/tmp/nginx.socket'
##attr(port, 'mask') <- strtoi("117", 8)
# Gets the port # from Heroku
port <- Sys.getenv('PORT')
shiny::runApp(
appDir = getwd(),
host = '0.0.0.0',
port = as.numeric(port)
)
# Runs the app in the working directory. By default this will search for an `app.R` file or
# a ui.R + server.R file combination
# In this case the port is now the address to the nginx proxy
# The host of 0.0.0.0 indicates the app runs at the web server's ip address
#
# run.R
# Swapboard
#
# Created by Tosin on 26/11/2019
# MIT License and shit
#
#library(rmarkdown)
library(shiny)
# When we run nginx we need to change R to point to the /app folder manually
#setwd('/app')
# Create a file at the path /tmp/app-initalized
# This tells nginx that the app is running, and it can now forward traffic to the custom 'port' below
# If this file is created, nginx will simply wait forever until the app says its running
##file.create("/tmp/app-initialized")
##port <- '/tmp/nginx.socket'
##attr(port, 'mask') <- strtoi("117", 8)
# Gets the port # from Heroku
# Runs the app in the working directory. By default this will search for an `app.R` file or
# a ui.R + server.R file combination
# In this case the port is now the address to the nginx proxy
# The host of 0.0.0.0 indicates the app runs at the web server's ip address
rmarkdown::run(
'Swapdash_v0.2.Rmd',
shiny_args = list(
port = port)
)
#
# run.R
# Swapboard
#
# Created by Tosin on 26/11/2019
# MIT License and shit
#
#library(rmarkdown)
library(shiny)
# When we run nginx we need to change R to point to the /app folder manually
#setwd('/app')
# Create a file at the path /tmp/app-initalized
# This tells nginx that the app is running, and it can now forward traffic to the custom 'port' below
# If this file is created, nginx will simply wait forever until the app says its running
##file.create("/tmp/app-initialized")
##port <- '/tmp/nginx.socket'
##attr(port, 'mask') <- strtoi("117", 8)
# Gets the port # from Heroku
# Runs the app in the working directory. By default this will search for an `app.R` file or
# a ui.R + server.R file combination
# In this case the port is now the address to the nginx proxy
# The host of 0.0.0.0 indicates the app runs at the web server's ip address
rmarkdown::run(
'Swapdash_v0.2.Rmd'
)
rmarkdown::run(
'Swapdash_v0.2.Rmd'
#  shiny_args = list(
#    port = port)
)
library(flexdashboard)
library(viridis)
library(tidyverse)
library(plotly)
library(shiny)
library(scales)
library(DT)
library(writexl)
library(echarts4r)
# Calculate average of x
output$avg_x <- renderText({
avg_x <- movies %>% pull(input$x) %>% mean() %>% round(2)
paste("Average", input$x, "=", avg_x)
})
# Output(s)
mainPanel(
plotOutput(outputId = "scatterplot"),
textOutput(outputId = "avg_x"), # avg of x
textOutput(outputId = "avg_y"), # avg of y
verbatimTextOutput(outputId = "lmoutput") # regression output
)
# Create scatterplot
output$scatterplot <- renderPlot({
ggplot(data = movies, aes_string(x = input$x, y = input$y)) +
geom_point()
})
# Output(s)
mainPanel(
plotOutput(outputId = "scatterplot"),
textOutput(outputId = "avg_x"), # avg of x
textOutput(outputId = "avg_y"), # avg of y
verbatimTextOutput(outputId = "lmoutput") # regression output
)
server <- function(input, output) {
# Create scatterplot
output$scatterplot <- renderPlot({
ggplot(data = movies, aes_string(x = input$x, y = input$y)) +
geom_point()
})
# Calculate average of x
output$avg_x <- renderText({
avg_x <- movies %>% pull(input$x) %>% mean() %>% round(2)
paste("Average", input$x, "=", avg_x)
})
# Calculate average of y
output$avg_y <- renderText({
avg_y <- movies %>% pull(input$y) %>% mean() %>% round(2)
paste("Average", input$y, "=", avg_y)
})
# Create regression output
output$lmoutput <- renderPrint({
x <- movies %>% pull(input$x)
y <- movies %>% pull(input$y)
summ <- summary(lm(y ~ x, data = movies))
print(summ, digits = 3, signif.stars = FALSE)
})
}
# Output(s)
mainPanel(
plotOutput(outputId = "scatterplot"),
textOutput(outputId = "avg_x"), # avg of x
textOutput(outputId = "avg_y"), # avg of y
verbatimTextOutput(outputId = "lmoutput") # regression output
)
server <- function(input, output) {
# Create scatterplot
output$scatterplot <- renderPlot({
ggplot(data = movies, aes_string(x = input$x, y = input$y)) +
geom_point()
})
# Calculate average of x
output$avg_x <- renderText({
avg_x <- movies %>% pull(input$x) %>% mean() %>% round(2)
paste("Average", input$x, "=", avg_x)
})
# Calculate average of y
output$avg_y <- renderText({
avg_y <- movies %>% pull(input$y) %>% mean() %>% round(2)
paste("Average", input$y, "=", avg_y)
})
# Create regression output
output$lmoutput <- renderPrint({
x <- movies %>% pull(input$x)
y <- movies %>% pull(input$y)
summ <- summary(lm(y ~ x, data = movies))
print(summ, digits = 3, signif.stars = FALSE)
})
}
# Create a Shiny app object
shinyApp(ui = ui, server = server)
# Output(s)
mainPanel(
plotOutput(outputId = "scatterplot"),
textOutput(outputId = "avg_x"), # avg of x
textOutput(outputId = "avg_y"), # avg of y
verbatimTextOutput(outputId = "lmoutput") # regression output
)
server <- function(input, output) {
# Create scatterplot
output$scatterplot <- renderPlot({
ggplot(data = movies, aes_string(x = input$x, y = input$y)) +
geom_point()
})
# Calculate average of x
output$avg_x <- renderText({
avg_x <- movies %>% pull(input$x) %>% mean() %>% round(2)
paste("Average", input$x, "=", avg_x)
})
# Calculate average of y
output$avg_y <- renderText({
avg_y <- movies %>% pull(input$y) %>% mean() %>% round(2)
paste("Average", input$y, "=", avg_y)
})
# Create regression output
output$lmoutput <- renderPrint({
x <- movies %>% pull(input$x)
y <- movies %>% pull(input$y)
summ <- summary(lm(y ~ x, data = movies))
print(summ, digits = 3, signif.stars = FALSE)
})
}
# Create a Shiny app object
shinyApp(server = server)
# Create regression output
lmoutput <- renderPrint({
x <- movies %>% pull(input$x)
y <- movies %>% pull(input$y)
summ <- summary(lm(y ~ x, data = movies))
print(summ, digits = 3, signif.stars = FALSE)
})
# access to data
load(url("http://s3.amazonaws.com/assets.datacamp.com/production/course_4850/datasets/movies.Rdata"))
cs_intent <- read_csv("/Volumes/Loopdisk/Swapboard/data/online_shoppers_intention\ 2.csv ")
# access to data
load(url("http://s3.amazonaws.com/assets.datacamp.com/production/course_4850/datasets/movies.Rdata"))
cs_intent <- read_csv("/Volumes/Loopdisk/Swapboard/data/online_shoppers_intention.csv ")
knitr::opts_knit$set(root.dir = '/Volumes/Loopdisk/Swapboard/')
library(flexdashboard)
library(viridis)
library(tidyverse)
library(plotly)
library(shiny)
library(scales)
library(DT)
library(writexl)
library(echarts4r)
# access to data
load(url("http://s3.amazonaws.com/assets.datacamp.com/production/course_4850/datasets/movies.Rdata"))
cs_intent <- read_csv("/Volumes/Loopdisk/Swapboard/data/online_shoppers_intention.csv ")
# access to data
load(url("http://s3.amazonaws.com/assets.datacamp.com/production/course_4850/datasets/movies.Rdata"))
setwd("/Volumes/Loopdisk/Swapboard/data/")
cs_intent <- read_csv("/Volumes/Loopdisk/Swapboard/data/online_shoppers_intention.csv ")
# access to data
load(url("http://s3.amazonaws.com/assets.datacamp.com/production/course_4850/datasets/movies.Rdata"))
#setwd("/Volumes/Loopdisk/Swapboard/data/")
cs_intent <- read_csv("/Volumes/Loopdisk/Swapboard/data/online_shoppers_intention.csv")
renderPlotly({
req(input$date)
movies_selected_date <- movies %>%
mutate(thtr_rel_date = as.Date(thtr_rel_date)) %>% # convert thtr_rel_date to Date format
filter(thtr_rel_date >= input$date[1] & thtr_rel_date <= input$date[2])
p <- ggplot(data = movies_selected_date, aes(x = input$x, y = input$y, color = input$z)) +
geom_point()
ggplotly(p)
})
install.packages("cowplot")
